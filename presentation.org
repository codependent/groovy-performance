* 2 Fast 2 Furious [0/5]

  - [ ] Objection #1: Why should I care about this stuff? Computers just get faster!

    - The free lunch is over. Free speedups come from increasing clock speeds, optimizing execution inside the CPU, and increasing the size of the CPU cache. Only CPU caches are getting bigger.

    - When was the last time you bought a computer that was faster than the one you last bought?
      
  - [ ] Objection #2: Isn't this just a matter of choosing the right algorithm?

    - Algorithm complexity does determine execution speed to a large degree

    - However, algorithm complexity always ignores constant factors

    - Those constant factors can be really high

    - A lot of this talk is about reducing those constant factors

  - [ ] Objection #3: Won't the JVM optimize this stuff for me?

    - The JVM will optimize a lot of stuff, but it can't work miracles

    - A lot of this talk is about getting groovy out of the way of the JVM so it can optimize

    - A lot of the rest of this talk is about using groovy to help the JVM do its job

  - [ ] Objection #4: My application doesn't need to go faster!

    - If this is the case then by all means ignore everything in this talk, move on to your next task

    - But, a lot of applications that are "fast enough" really are not. "Fast enough" is often a lie we tell ourselves because we don't know how to solve the problem.

    - Faster often opens up new use cases for your code. Everyone hated source code control before git. Now git is used by everyone and it has changed how we as programmers work. A lot of this has to do with how fast git is. The concepts of merging and branching were well understoof before git, but people avoided them because they were slow. Now everyone branches and merges several times a day, mostly because git is fast.

  - [ ] Objection #5: Groovy is just inherently slow, don't bother.

    - Claim: If you give me a java project I can make it at least as fast or faster by adding Groovy. In some sense this is an empty claim, I can give you back the project as is and it's just as fast as it was. However, I do think that adding Groovy can increase both clarity and speed.

    - Most of what I have done over the past 3 years is write performance critical code, and I always reach for Groovy.

* Assumptions [0/5]

- [ ] You actually have a performance problem

- [ ] You know how to measure application performance and how to measure improvements

- [ ] You know the basics of algorithm complexity (O(n) notation)

- [ ] You know the basics of how the JVM operates and what makes for fast executing code

- [ ] If you don't know these things no worries, you will still hopefully get a lot out of this talk, just be careful about applying these techniques. In other words, don't run out and add @CompileStatic to all of your code. Depending on your application it may not actually go any faster and may make your code worse.

* Groovy Gotchas [0/6]

- [ ] Much fewer than there used to be. For the most part compiled static Groovy code is about as performant as Java code.

  - Java 8 is a big win for groovy. Java 8 is very agressive about inlining code.

  - I used to recommend against using arrays directly in Groovy. Once hotspot has optimized a method there is no difference between Groovy and Java array access. This is acutally quite shocking.

  - I used to also have concerns about reference equality in Groovy. I don't remember why, but it also is compiled to the same byte codes as on the JVM.

- [ ] Gotcha #1: Boxing/Unboxing

  - Implicit box/unbox operations can really slow down a hot inner loop.

  - How much of a slow down? I've seen 3x slowdown.

  - However, this isn't really Groovy specific because Java has the same problem.

  - See fastUtils in Groovy class.

- [ ] Gotcha #2: Implcit casting

  - Boxing/unboxing is really just a special case of this.

  - Groovy tends to be much slower about casts because it has to hook into asType().

  - This applies even to primitive casts. Bottom line: avoid casts in hot spots if necessary.

  - Amazingly enough, any type of non-exact match causes this problem. Even assigning to references of a super class, for instance see Groovy.referenceEquals()

- [ ] Gotcha #3: Exception based dispatch

  - propertyMissing/methodMissing is handled through throwing exceptions, avoid this, it is really slow.

  - This can show up in unexpected areas. For example accessing arrays outside of their bounds works in Groovy, but it is handled through catching exceptions and re-trying array access.

- [ ] Gotcha #4: Inner classes

  - Non-static inner classes "work" but are not natural in groovy and lead to surprising behavior. Some of these are lower performance due to accessing methods and properties via reflection, i.e. slow code.

  - Solution: Use static inner classes for speed and encapsulation or use closures.

- [ ] Gotcha #5: Switch statements

  - Groovy switch statements are SIGNIFICANTLY slower than Java versions. In simple tests. dispatching on integers, Java is 50x faster. Why?

  - Java switches always jump to computed offsets. If you can't jump based on an integer Java won't support your type. This is why it took so long to get String based switches. They had to set in stone how Strings compute hash codes so that offsets could be pre-computed based on absolutely known string hash codes.

  - Groovy switches are driven off of the isCase operator. This means a switch statement is just a series of calls to the isCase method. This is really slow.

  - Solution: Use if/else and fast tests for a small number of tests. For large numbers of tests use fast value types and maps.
* Groovy Annotations for Speed [0/8]

  - [ ] @CompileStatic

    - If there is a single thing you remember from this talk it should be use @CompileStatic as a first step when you have an application performance problem.

    - This annotation removes a lot of the dynamicity of Groovy. Properties and methods must be resolvable at compile time, no use of propertyMissing/methodMissing. Types must match. Groovy extension methods such as find/findAll/each are legal. Groovy style casting is legal. Groovy code with @CompileStatic enabled looks a lot like Kotlin code. 

  - [ ] @TypeChecked

    - Does all of the type checking @CompileStatic does and the same rules apply.

    - However it doesn't do static compilation, just the type checking part, so @TypeCheck'ed code won't actually run any faster than normal Groovy code. So why did I include this?

    - @TypeChecked does prevent dispatch based on propertyMissing/methodMissing which is extraordinarily slow.

  - [ ] @Lazy

    - Only initializes a property if it is called; it's a simple one item cache.

    - With volatile it correctly implements double checked locking, which most people don't get right.

    - Very useful for objects which have expensive calls which are not always needed. I've used this extensively for templates with conditional logic. The conditional logic means that some properties are not needed and should not be computed.

  - [ ] @Memoized

    - Caches invocations of your method by adding a hidden map to your class

    - If you have not invoked your method with a particular set of parameters, the logic of your method is called, the parameters are added as keys of the hidden map, and the returned value is added as the value of those keys

    - If you have invoked your method with a particular set of parameters, the parameters are used as the key to look up the correct return value in the cache

    - Is a simple, somewhat tunable cache. For simple use cases it gets the job done

  - [ ] @Immutable

    - Doesn't make your code faster by itself, but does allow you to do fast things with your class

    - @Immutable classes are inherently thread safe, multi-threading can substantially improve performance

    - @Immutable classes also have correct equals() and hashCode() methods. This means they can be used as keys in maps or added to sets. This means that you can eliminate linear search algorithms O(n) with hash based O(1) algorithms 

  - [ ] @Sortable

    - Again, it doesn't make your code faster by itself, by does allow you to do fast things with your class

    - @Sortable code is usable in SortedSet, meaning O(n/2) searches become O(ln n) searches

    - @Sortable code is usable in NavigableSet, meaning range searches are now cheap and easy

  - [ ] @TailRecursive

    - Specialized, if you don't know what tail recursion is, ignore this for now.

    - If your method is most naturally expressed as a recursion, use this to convert the method to iteration

  - [ ] @Slf4j and friends in groovy.util.logging

    - Lots of logging can lead to performance degradation if the logging is done incorrectly

    - Parametrized logging is NOT a valid solution IMNSHO. It doesn't work in all cases and can lead to unnecessary array creation

    - The only way to log correctly is to use log guard statements consistently, like: if(log.isDebugEnabled()) { log.debug(...) }, this is of course a lot of typing, easy to forget, and just plain ugly

    - The Groovy logging annotations give you that for free, they do the right thing every time.

* What makes these annotations work and can I do the same thing [0/2]

- [ ] The secret is code injection, re-arranging, and re-writing your code

  - @Lazy, @Memoized, and @Slf4j wrap code around your code. The semantics are the same, the JVM will just execute it more efficiently

  - @Sortable and @Immutable add code to your code to enforce semantics of immutability and comparability

  - @TailRecursive re-writes your code to be iterative instead of recursive

  - @CompileStatic generates different byte code than normal groovy code

- [ ] You can absolutely do the same thing

* Let's do what Groovy does! [0/2]

- [ ] Easiest First: Re-arrange code at runtime with builders

  - Dynamic groovy code is usually the easiest and most natural way to express something

  - However, it may not lead to the most efficient execution

  - Solution: combine easy Groovy syntax with uglier execution, using a builder as your bridge between the two

  - See Grades.groovy

- [ ] Easy to Understand but possibly dangerous: Compile strings

  - Basic idea is that you have a string representation of code and you also have a groovy compiler at all times, make use of both to turn strings into executable code

  - Compiler can be either the GroovyShell or the GroovyClassLoader

  - Can also be used to load/reload and optimize scripts at runtime

#+STARTUP: indent
